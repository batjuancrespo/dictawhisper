<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transcripción Simple con Gemini (Todo en Uno)</title>
    
    <script type="importmap">
      {
        "imports": {
          "@google/genai": "https://esm.sh/@google/genai@^0.8.0" 
        }
      }
    </script>

    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            background-color: #f0f2f5;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
            color: #333;
        }
        .container { background-color: #ffffff; padding: 25px 35px; border-radius: 12px; box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08); text-align: center; width: 100%; max-width: 750px; }
        h1 { color: #1c1e21; margin-bottom: 10px; font-size: 28px; font-weight: 600; }
        p#status { color: #555; min-height: 20px; margin-bottom: 20px; font-size: 15px; }
        .controls button { padding: 12px 20px; margin: 10px 8px; font-size: 16px; border: none; border-radius: 8px; cursor: pointer; background-color: #007aff; color: white; transition: background-color 0.2s ease-in-out, transform 0.1s ease; font-weight: 500; }
        .controls button:hover { background-color: #005ecb; }
        .controls button:active { transform: scale(0.98); }
        .controls button:disabled { background-color: #d1d5db; cursor: not-allowed; }
        #recordButton.recording { background-color: #ff3b30; }
        #recordButton.recording:hover { background-color: #d92c23; }
        h2 { margin-top: 30px; margin-bottom: 10px; font-size: 20px; color: #333; text-align: left; font-weight: 500; }
        #transcriptionOutput { width: 100%; box-sizing: border-box; min-height: 250px; margin-top: 5px; padding: 15px; border: 1px solid #ccd0d5; border-radius: 8px; font-size: 16px; line-height: 1.6; text-align: left; white-space: pre-wrap; background-color: #f9f9f9; color: #1c1e21; overflow-y: auto; }
        #transcriptionOutput[placeholder]:empty:before { content: attr(placeholder); color: #888; font-style: italic; }
        .error-message { color: #d93025; margin-top: 15px; font-size: 14px; min-height: 18px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Dictado Inteligente con Gemini</h1>
        <p id="status">Haz clic en "Iniciar Dictado" y habla.</p>
        <div class="controls">
            <button id="recordButton">Iniciar Dictado</button>
            <button id="copyButton" style="display:none;">Copiar Transcripción</button>
        </div>
        <h2>Transcripción Pulida:</h2>
        <div id="transcriptionOutput" contenteditable="true" placeholder="La transcripción aparecerá aquí..."></div>
        <p id="error" class="error-message"></p>
    </div>

    <script type="module">
        // Volviendo al método de importación nombrada original
        import { GoogleGenerativeAI } from "@google/genai"; 

        const API_KEY = "AIzaSyASbB99MVIQ7dt3MzjhidgoHUlMXIeWvGc"; 
        const MODEL_NAME = "gemini-1.0-pro-latest"; 

        const recordButton = document.getElementById('recordButton');
        const copyButton = document.getElementById('copyButton');
        const transcriptionOutput = document.getElementById('transcriptionOutput');
        const statusDisplay = document.getElementById('status');
        const errorDisplay = document.getElementById('error');

        let mediaRecorder;
        let audioChunks = [];
        let isRecording = false;
        let genAIInstance; 

        function initializeGenAI() {
            if (!API_KEY || API_KEY === "TU_API_KEY_DE_GOOGLE_AQUI") { 
                const errorMsg = "API Key no configurada correctamente...";
                errorDisplay.textContent = errorMsg;
                statusDisplay.textContent = "Error de configuración.";
                recordButton.disabled = true;
                console.error(errorMsg);
                return false;
            }
            try {
                // Usar la importación nombrada directamente
                genAIInstance = new GoogleGenerativeAI(API_KEY);
                console.log("GoogleGenAI inicializado correctamente usando importación nombrada.");
                return true;
            } catch (error) {
                console.error("Error inicializando GoogleGenerativeAI (con importación nombrada):", error);
                errorDisplay.textContent = `Error inicializando API (importación nombrada): ${error.message}`;
                recordButton.disabled = true;
                return false;
            }
        }

        async function startRecording() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                errorDisplay.textContent = "La API MediaDevices no es soportada por tu navegador.";
                statusDisplay.textContent = "Error de compatibilidad del navegador.";
                return;
            }
            try {
                errorDisplay.textContent = ""; 
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                let options = { mimeType: 'audio/webm' };
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options = { mimeType: 'audio/ogg; codecs=opus' };
                    if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                        options = {}; 
                    }
                }
                mediaRecorder = new MediaRecorder(stream, options);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    statusDisplay.textContent = "Procesando audio...";
                    recordButton.disabled = true;
                    copyButton.style.display = 'none';
                    const audioBlob = new Blob(audioChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
                    audioChunks = []; 
                    await processAudioWithGemini(audioBlob);
                    recordButton.disabled = false;
                    if (transcriptionOutput.innerText.trim() !== "") copyButton.style.display = 'inline-block';
                    stream.getTracks().forEach(track => track.stop());
                };
                
                mediaRecorder.onerror = (event) => {
                    console.error("Error de MediaRecorder:", event.error);
                    errorDisplay.textContent = `Error de MediaRecorder: ${event.error.name}`;
                    statusDisplay.textContent = "Error durante la grabación.";
                    isRecording = false;
                    recordButton.textContent = "Iniciar Dictado";
                    recordButton.classList.remove("recording");
                    recordButton.disabled = false;
                    stream.getTracks().forEach(track => track.stop());
                };

                mediaRecorder.start();
                isRecording = true;
                recordButton.textContent = "Detener Dictado";
                recordButton.classList.add("recording");
                statusDisplay.textContent = "Grabando... Habla ahora.";
                transcriptionOutput.innerHTML = ""; 
                copyButton.style.display = 'none';

            } catch (error) {
                console.error("Error al iniciar grabación:", error);
                let userFriendlyError = `Error al iniciar grabación: ${error.message}.`;
                if (error.name === "NotAllowedError") userFriendlyError = "Permiso para usar el micrófono denegado.";
                else if (error.name === "NotFoundError") userFriendlyError = "No se encontró un micrófono.";
                errorDisplay.textContent = userFriendlyError;
                statusDisplay.textContent = "Error al grabar.";
                isRecording = false;
                recordButton.textContent = "Iniciar Dictado";
                recordButton.classList.remove("recording");
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== "inactive") {
                mediaRecorder.stop();
                isRecording = false;
                recordButton.textContent = "Iniciar Dictado";
                recordButton.classList.remove("recording");
            }
        }

        async function processAudioWithGemini(audioBlob) {
            if (!genAIInstance) {
                errorDisplay.textContent = "Gemini AI no está inicializado.";
                statusDisplay.textContent = "Error de API.";
                return;
            }
            if (audioBlob.size === 0) {
                statusDisplay.textContent = "No se grabó audio.";
                return;
            }

            statusDisplay.textContent = "Convirtiendo audio...";
            const base64Audio = await blobToBase64(audioBlob);
            if (!base64Audio) {
                errorDisplay.textContent = "Error al convertir audio.";
                statusDisplay.textContent = "Error de conversión.";
                return;
            }

            statusDisplay.textContent = "Enviando a Gemini...";
            const prompt = `
                Por favor, transcribe el siguiente audio.
                Luego, pule la transcripción eliminando palabras de relleno (como "um", "eh", "bueno", "o sea", "pues"), repeticiones innecesarias y falsos comienzos.
                IMPORTANTE: Si en el dictado se mencionan explícitamente signos de puntuación como "coma", "punto", "punto y coma", "dos puntos", "signo de interrogación", "signo de exclamación", "abrir paréntesis", "cerrar paréntesis", "abrir corchetes", "cerrar corchetes", "abrir comillas", "cerrar comillas", "guion", "raya", o se indica "nueva línea", "siguiente línea", "punto y aparte" o "nuevo párrafo", por favor, aplica esos signos de puntuación o saltos de línea correspondientes en el texto final.
                Corrige errores gramaticales menores si son obvios, pero mantén el significado y el estilo del hablante.
                El resultado debe ser únicamente el texto pulido y formateado. No incluyas preámbulos ni comentarios sobre el proceso.
            `;

            try {
                const model = genAIInstance.getGenerativeModel({ model: MODEL_NAME });
                const result = await model.generateContent({
                    contents: [
                        { role: "user", parts: [{text: prompt}] },
                        { role: "user", parts: [{ inlineData: { mimeType: audioBlob.type || 'audio/webm', data: base64Audio }}] }
                    ]
                });
                const response = result.response;
                const polishedText = response.text();

                if (polishedText) {
                    transcriptionOutput.innerText = polishedText.trim();
                    statusDisplay.textContent = "Transcripción completada.";
                    copyButton.style.display = 'inline-block';
                } else {
                    transcriptionOutput.innerHTML = "<em>Respuesta vacía de Gemini.</em>";
                    statusDisplay.textContent = "Respuesta vacía de Gemini.";
                }
            } catch (error) {
                console.error("Error al procesar con Gemini:", error);
                let detailedError = error.message;
                if (error.response?.promptFeedback) detailedError += ` Feedback: ${JSON.stringify(error.response.promptFeedback)}`;
                else if (error.message?.includes("API key not valid")) detailedError = "API Key no válida.";
                errorDisplay.textContent = `Error con Gemini: ${detailedError}`;
                transcriptionOutput.innerHTML = `<em>Error procesando.</em>`;
                statusDisplay.textContent = "Error en el procesamiento.";
            }
        }

        function blobToBase64(blob) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    const base64data = reader.result;
                    if (typeof base64data === 'string') resolve(base64data.split(',')[1]);
                    else reject(new Error("FileReader no devolvió una cadena."));
                };
                reader.onerror = (error) => reject(error);
                reader.readAsDataURL(blob);
            });
        }

        function copyTranscription() {
            const textToCopy = transcriptionOutput.innerText;
            if (textToCopy.trim() === "") return;
            navigator.clipboard.writeText(textToCopy)
                .then(() => {
                    const originalStatus = statusDisplay.textContent;
                    statusDisplay.textContent = "¡Transcripción copiada!";
                    setTimeout(() => {
                        if (statusDisplay.textContent === "¡Transcripción copiada!") statusDisplay.textContent = originalStatus;
                    }, 2500);
                })
                .catch(err => {
                    console.error('Error al copiar texto: ', err);
                    statusDisplay.textContent = "Error al copiar.";
                });
        }

        recordButton.addEventListener('click', () => {
            if (!genAIInstance && !initializeGenAI()) return; 
            if (isRecording) stopRecording();
            else startRecording();
        });

        copyButton.addEventListener('click', copyTranscription);

        document.addEventListener('DOMContentLoaded', () => {
            if (!initializeGenAI()) {
                console.warn("La inicialización de GenAI falló al cargar la página.");
            }
        });
    </script>
</body>
</html>
